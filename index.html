<html>
    <head>
        <meta charset="utf-8">
        <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.15/css/jquery.dataTables.min.css">

        <!-- Latest compiled JavaScript -->
        <script
          src="https://code.jquery.com/jquery-3.4.1.min.js"
          integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
          crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
        <script src="datamaps.js"></script>
        <script src="local_country_variables/gdpr_countries.js"></script>
        <script src="local_country_variables/included_countries.js"></script>
    </head> 
    <body>
        <style>
          .row_elem {
            margin-left: 20px;
            margin-right: 20px;
          }

          #legend_labels, .content_elem {
            margin-left: 10px;
          }

          .content {
            align-items: center;
          }

          #legend_title {
            font-weight: bold;
          }

          .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
          }

          .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
          }

          .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
          }

          .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
          }

          input:checked + .slider {
            background-color: #2196F3;
          }

          input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
          }

          input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
          }

          /* Rounded sliders */
          .slider.round {
            border-radius: 34px;
          }

          .slider.round:before {
            border-radius: 50%;
          }

          .content {
            margin: 50px;
          }
        </style>
        <h1 style="text-align:center">Internationally Blocked Domains Demo</h1>
        <div class = "container" style="text-align:center;padding:20px;">Click on a country to see shared censored website data in other countries across the world.</div>
        <div style="display:flex;">
          <div class = "row_elem" id="basic_chloropleth" style="width: 80%; height: 750px;"></div>
          <div class = "row_elem" id="legend" style="height: 750px;">
            <div id = "legend_title">Legend</div>
            <div id = "max_val"></div>
            <div style="display:flex; flex-direction: row;">
              <div class = "legend_elem" id = "legend_div" style = "height: 100%; width: 50px; min-height: 750px;"></div>
              <div class = "legend_elem" id = "legend_labels" style="height: 100%;"></div>
            </div>
            <div id = "min_val"></div>
          </div>    
          </div>
        </div>
        <br />
        <div class = "content" id = "vis_mode" style = "display: flex;">
          <div class = "content_elem">
            <label class="switch">
              <input type="checkbox" onchange="toggleMode()">
              <span class="slider round"></span>
            </label>
          </div>
          <div class = "content_elem" id = "curr_mode">World Map</div>
        </div>
        <b><p class = "content" id = 'selected_country' style="font-size: 24px;"></p></b>
        <div class = "content" id = "domain_table" style="height: 500px; overflow-y: auto;"></div>
        <script>
          var ccMap = {};
          const gray = "#d3d3d3";
          const modes = ["World Map", "Force-Directed"];
          var currModeIdx = 0;
          var currMode = modes[currModeIdx];
          var combined_similarities;

          function toggleMode() {
            currModeIdx = 1 - currModeIdx;
            currMode = modes[currModeIdx];
            document.getElementById("curr_mode").innerHTML = currMode;
            if (currModeIdx == 0) {
              enableWorldMap();
            } else {
              enableForceDirected();
            }
          }

          function enableWorldMap() {
            document.getElementById("basic_chloropleth").innerHTML = "";
            document.getElementById("legend").style.display = "";
            var country = "United States of America";
            populateMap(country);
            document.getElementById("selected_country").innerHTML = "Selected Country: <div style = 'display: inline; color: blue;'>" + country + "</div>";
          }

          function enableForceDirected() {
            document.getElementById("basic_chloropleth").innerHTML = "";
            document.getElementById("basic_chloropleth").style.width = "100%";
            document.getElementById("legend").style.display = "none";
            generateForceDirected();
          }

          String.prototype.replaceAll = function(search, replacement) {
              var target = this;
              return target.split(search).join(replacement);
          };

          function calculateForceData() {
            var forceNodes = [];
            var forceLinks = [];
            var uniqueNodes = {};
            var ccToCountry = {};
            var possibleNode;
            var splitKey;
            var cc;
            var count = 0;
            var target;
            var source;
            for (const [key, value] of Object.entries(combined_similarities)) {
              splitKey = key.split(", ");
              possibleNode = splitKey[0].replace("(", "").replaceAll("'", "\"");
              strippedPossibleNode = possibleNode.replaceAll("\"", "");
              if (!possibleNode.includes("\"")) {
                possibleNode = '"' + possibleNode + '"';
              }

              if (possibleNode == '"Lichtenstein"') {
                possibleNode = '"Liechtenstein"';
              }

              if (possibleNode == '"United States of America"') {
                possibleNode = '"United States"';
              }
              
              if (!(possibleNode in uniqueNodes)) {
                if (gdpr_countries.includes(strippedPossibleNode)) {
                  if (!("GDPR" in uniqueNodes)) {
                    forceNodes.push({ "character": "GDPR", "id": count, "influence": 40 });
                    uniqueNodes["GDPR"] = count;
                    count++;
                  }
                } else {
                  uniqueNodes[possibleNode] = count;
                  forceNodes.push({ "character": strippedPossibleNode, "id": count, "influence": 40 });
                  count++;
                }
                cc = ccMap[possibleNode];
                ccToCountry[cc] = strippedPossibleNode;
              }
            }
            for (const [key, value] of Object.entries(combined_similarities)) {
              splitKey = key.split(", ");
              o_source = splitKey[0].replaceAll("'", "").replace("(", "");
              o_target = splitKey[1].replaceAll("'", "").replace(")", "");
              if (o_source == "United States of America") {
                o_source = 'United States';
              }
              if (o_target == "United States of America") {
                o_target = 'United States';
              }
              if (gdpr_countries.includes(o_source)) {
                source = uniqueNodes["GDPR"];
              } else {
                source = uniqueNodes["\"" + o_source + "\""];
              }
              var country_o_target = ccToCountry[o_target];
              if (gdpr_countries.includes(country_o_target)) {
                target = uniqueNodes["GDPR"];
              } else {
                target = uniqueNodes["\"" + country_o_target + "\""];
              }
              var weight = value[0].similarity * 500;
              if (source != undefined && target != undefined && weight) {
                var newLink = { "source": source, "target": target, "weight": weight };
                forceLinks.push(newLink);
              }
            }
            return {
              "nodes": forceNodes,
              "links": forceLinks.slice(1,forceLinks.length),
            }
          }

          function generateForceDirected() {
            var margin = {
              top: 20,
              bottom: 50,
              right: 30,
              left: 50
            };
            // var width = 960 - margin.left - margin.right;
            // var height = 700 - margin.top - margin.bottom;
            var width = $('#basic_chloropleth').width();
            var height = $('#basic_chloropleth').height();
            //Create an SVG element and append it to the DOM
            var svgElement = d3.select("#basic_chloropleth")
                      .append("svg")
                      .attr({"width": width, "height": height})
                      .append("g")
                      .attr("transform","translate("+margin.left+","+margin.top+")");
            //Load External Data
            dataset = calculateForceData();
            //Extract data from dataset
            var nodes = dataset.nodes;
            var links = dataset.links;
            var radius = 6;
            var padding = 20;
            //Create Force Layout
            var force = d3.layout.force()
                    .size([width, height])
                    .nodes(nodes)
                    .links(links)
                    .gravity(0.02)
                    .charge(-100)
                    // .data(links)
                    // .enter()
                    .linkDistance(function(d) { console.log(d); return d.weight * 500; });
            //Add links to SVG
            var link = svgElement.selectAll(".link")
                  .data(links)
                  .enter()
                  .append("line")
                  .attr("stroke", "white")
                  .attr("stroke-width", function(d){ return d.weight; })
                  // .attr("class", "link");
            //Add nodes to SVG
            var node = svgElement.selectAll(".node")
                  .data(nodes)
                  .enter()
                  .append("g")
                  .attr("class", "node")
                  .call(force.drag);
            //Add labels to each node
            var label = node.append("text")
                    .attr("dx", 12)
                    .attr("dy", "0.35em")
                    .attr("font-size", 14)
                    .text(function(d){ return d.character; });
            //Add circles to each node
            var circle = node.append("circle")
                    .attr("r", function(d){ return radius; })
                    // .attr("fill", function(d){ return c10(d.zone*10); });
            //This function will be executed for every tick of force layout
            force.on("tick", function(){
              //Set X and Y of node
              node.attr("r", function(d){ return d.influence; })
              .attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius - padding, d.x)); })
              .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius - padding, d.y)); });
                // .attr("cx", function(d){ return d.x; })
                // .attr("cy", function(d){ return d.y; });
              //Set X, Y of link
              link.attr("x1", function(d){ return d.source.x; })
              link.attr("y1", function(d){ return d.source.y; })
              link.attr("x2", function(d){ return d.target.x; })
              link.attr("y2", function(d){ return d.target.y; });
              //Shift node a little
              node.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")"; 
              });
            });
            // });
            //Start the force layout calculation
            force.start();
          }

          function formatResults(sortedData) {
            if (!sortedData.length) {
              document.getElementById("domain_table").innerHTML = "<p>No known blocked websites, though website takedowns have been enacted. See <a href = 'https://www.ice.gov/factsheets/ipr-in-our-sites' target = '_blank'>Operation In Our Sites</a>.</p>";
              document.getElementById("domain_table").style.height = "100px";
              return;
            }
            document.getElementById("domain_table").style.height = "500px";
            var tableData = '<table class="table table-bordered table-striped">';
            tableData += '<th>Country</th>';
            tableData += '<th>Count</th>';
            tableData += '<th>Similarity</th>';
            tableData += '<th>Domains</th>';
            for (var i = 0; i < sortedData.length; i++) {
              tableData += '<tr>';
              tableData += '<td>'+sortedData[i][0]+'</td>';
              tableData += '<td>'+sortedData[i][1].count+'</td>';
              tableData += '<td>'+sortedData[i][1].similarity+'</td>';
              tableData += '<td>';
              var allDomains = sortedData[i][1].domains;
              for (var domainCount = 0; domainCount < allDomains.length; domainCount++) {
                tableData += allDomains[domainCount] + '<br>';
              }
              tableData += '</td>';
              tableData += '</tr>';
            }
            document.getElementById("domain_table").innerHTML = tableData;
          }

          function condenseGDPR(data) {
            const dataArray = Object.entries(data);
            const nonGDPRDataArray = dataArray.filter(x => !gdpr_countries.includes(x[0]));
            const GDPRDataArray = dataArray.filter(x => gdpr_countries.includes(x[0]));
            if (GDPRDataArray.length) {
              const GDPRDomains = GDPRDataArray[0][1].domains;
              const GDPRCount = GDPRDataArray[0][1].count;
              const GDPRSimilarity = GDPRDataArray[0][1].similarity;
              const GDPRElement = [["GDPR", { "count": GDPRCount, "domains": GDPRDomains, "similarity": GDPRSimilarity }]];
              const condensedDataArray = nonGDPRDataArray.concat(GDPRElement)
              return condensedDataArray;
            }
            return nonGDPRDataArray;
          }

          function sortResults(data, valueName) {
            data.sort(function(a, b) {
              const aCount = a[1][valueName];
              const bCount = b[1][valueName];
              return bCount - aCount;
            });
            return data;
          }

          function getDomainData(country, inputData) {
            $.ajax( {
              url: "notebooks/common_domains/" + country + "-common-domains.csv",
              type: "GET",
              async: true,
              dataType: "text",
              error: function () {
                document.getElementById("domain_table").innerHTML = '<table class="table table-bordered table-striped">No data available</table>';
              },
              success: function ( rawDomainData ) {
                var domainData = rawDomainData.split(/\r?\n|\r/);
                var tableData = {};
                var currCountry;
                var countryCount = 0;
                var currDomains = [];
                var skipRow = false;
                for (var count = 0; count < domainData.length - 1; count++) {
                  var cellData = domainData[count].split(",");
                  if (count == 0) {
                  } else {
                    if (cellData[1] === country || cellData[2] === country) {
                      var otherCountry = cellData[1];
                      if (cellData[1] === country) {
                        otherCountry = cellData[2];
                      }
                      if (count == 1) {
                        currCountry = otherCountry;
                      }
                      if (otherCountry === currCountry && count < domainData.length - 2) {
                        countryCount += 1;
                        currDomains.push(cellData[3] + '.' + cellData[4]);
                      } else {
                        if (count >= domainData.length - 2) {
                          countryCount += 1;
                          currDomains.push(cellData[3] + '.' + cellData[4]);
                        }
                        if (currCountry) {
                          var correctCurrCountry = currCountry;
                          if (currCountry == 'Lichtenstein') {
                            correctCurrCountry = 'Liechtenstein';
                          }
                          var inputDataKey = "('" + country + "', '" + ccMap['"' + correctCurrCountry + '"'] + "')";
                          tableData[currCountry] = {"count": countryCount, "domains": [], "similarity": inputData[inputDataKey][0].similarity}
                          for (var c = 0; c < currDomains.length; c++) {
                            tableData[currCountry].domains.push(currDomains[c]);
                          }
                        }
                        countryCount = 0;
                        currDomains = [];
                        currCountry = otherCountry;
                        countryCount += 1;
                        currDomains.push(cellData[3] + '.' + cellData[4]);
                      }
                    }
                  }
                }
                sortedTableData = sortResults(condenseGDPR(tableData), 'count');
                formatResults(sortedTableData);
            }});
          }

          function rgbToHex(rgb) { 
            var hex = Number(rgb).toString(16);
            if (hex.length < 2) {
                 hex = "0" + hex;
            }
            return hex;
          }

          function fullColorHex(r,g,b) {
            var red = rgbToHex(r);
            var green = rgbToHex(g);
            var blue = rgbToHex(b);
            return "#" + red+green+blue;
          }

          function numToHex(num) {
            var color_line = [0, 0, 255];
            curr_hex = fullColorHex(Math.round(num * color_line[0]), Math.round(num * color_line[1]), Math.round(num * color_line[2]));
            return curr_hex;
          }

          function deriveColorScale(data) {
              var fills = {};
              var curr_similarity;
              var country_limits = {};
              var split_country;
              var start_country;
              for (var country in data) {
                  split_country = country.split(", ")[0];
                  start_country = split_country.replace('(', '').replace(/'/g,'');
                  curr_similarity = data[country][0].similarity;
                  if (country_limits[start_country]) {
                    var curr_max = country_limits[start_country].max;
                    var curr_min = country_limits[start_country].min;
                    if (curr_similarity > curr_max) {
                      country_limits[start_country].max = curr_similarity;
                    }
                    if (curr_similarity < curr_min) {
                      country_limits[start_country].min = curr_similarity;
                    }
                  } else {
                    country_limits[start_country] = { "max": curr_similarity, "min": curr_similarity };
                  }
              }
              var scaled_frac;
              for (var country in data) {
                  split_country = country.split(", ")[0];
                  start_country = split_country.replace('(', '').replace(/'/g,'');
                  curr_similarity = data[country][0].similarity;

                  var curr_max = country_limits[start_country].max;
                  var curr_min = country_limits[start_country].min;

                  scaled_frac = (curr_similarity - curr_min) / (curr_max - curr_min);
                  curr_hex = numToHex(scaled_frac);
                  fills[country] = curr_hex;
              }
              fills["defaultFill"] = gray;
              fills["selected"] = "#218023";
              return fills;
          }

          function generateFillKeys(country, data) {
              var fillKeys = {};
              var c1;
              var c2;
              var split_pair;
              var uniqueCCs = [];
              for (var pair in data) {
                split_pair = pair.split(", ");
                c1 = split_pair[0].slice(2,split_pair[0].length - 1);
                c2 = split_pair[1].slice(1,split_pair[1].length - 2);
                if (c1 == country) {
                  fillKeys[c2] = { "fillKey": pair, "similarity": data[pair][0].similarity };
                }
              }
              if (country == "United States of America") {
                fillKeys[ccMap["\"United States\""]] = { "fillKey": "selected" };
              } else {
                fillKeys[ccMap["\"" + country + "\""]] = { "fillKey": "selected" };
              }
              return fillKeys;
          }

          function drawLegendIntervals(min_similarity, max_similarity, num_intervals) {
            const similarity_range = max_similarity - min_similarity;
            const jump = similarity_range / num_intervals;
            const legend_labels = document.getElementById("legend_labels");
            const map_height = document.getElementById("basic_chloropleth").style.height;
            const div_height = parseInt(map_height.slice(0, map_height.length - 2))/num_intervals;
            legend_labels.innerHTML = ""
            for (var i = num_intervals; i > 0; i--) {
              if (i == num_intervals) {
                legend_labels.innerHTML += "<div style = 'height:" + div_height + "'></div>"
                continue;
              }
              legend_labels.innerHTML += "<div id = 'max_val' style = 'height:" + div_height + ";'>" + Math.round((min_similarity + jump * i) * Math.pow(10,6))/Math.pow(10,6) + "</div>"
            }
          }

          function drawLegend(country, fills, fillKeys) {
            var legend_div = document.getElementById("legend_div");
            var min_similarity = 0;
            var max_similarity = -Infinity;
            var min_similarity_key;
            var max_similarity_key;
            var max_color;
            var min_color;
            var curr_similarity;
            // for (var key in fillKeys) {
            //   curr_similarity = fillKeys[key].similarity;
            //   if (curr_similarity < min_similarity) {
            //     min_similarity = curr_similarity;
            //     min_similarity_key = key;
            //   }
            //   if (curr_similarity > max_similarity) {
            //     max_similarity = curr_similarity;
            //     max_similarity_key = key;
            //   }
            // }
            var currFill;
            var newMax = -Infinity;
            var newMin = Infinity;
            for (const [key, value] of Object.entries(fills)) {
              if (value != "#NaNNaNNaN") {
                currFill = parseInt("0x" + value.slice(1, value.length).toUpperCase());
                if (currFill > newMax && key != "selected" && key != "defaultFill") {
                  newMax = currFill;
                  max_key = key;
                }
                if (currFill < newMin && key != "selected" && key != "defaultFill") {
                  newMin = currFill;
                  min_key = key;
                }
              }
            }
            // var min_key = "('" + country + "', '" + min_similarity_key + "')";
            // var max_key = "('" + country + "', '" + max_similarity_key + "')";
            // min_color = fills[min_key];
            // max_color = fills[max_key];
            min_similarity = combined_similarities[min_key][0].similarity;
            min_color = numToHex(min_similarity / (newMax - newMin));
            max_similarity = combined_similarities[max_key][0].similarity;
            max_color = numToHex(max_similarity / (max_similarity - min_similarity));
            if (min_color == "#NaNNaNNaN") {
              min_color = "black";
            }
            if (max_color == "#NaNNaNNaN") {
              max_color = "black";
            }
            const legend_input = "linear-gradient(to top, " + min_color + ", " + max_color + ")";
            document.getElementById("min_val").innerHTML = Math.round(min_similarity * Math.pow(10,6))/Math.pow(10,6);
            document.getElementById("max_val").innerHTML = Math.round(max_similarity * Math.pow(10,6))/Math.pow(10,6);
            legend_div.style.backgroundImage = legend_input;
            return [min_similarity, max_similarity];
          }

          function populateMap(country) {
            var similarity_limits;
            var min_similarity;
            var max_similarity;
            const num_intervals = 5;
            const countryCodesURL = "https://raw.githubusercontent.com/daylight-lab/III/master/shared/data/country-codes/countries_codes_and_coordinates.csv";
            if (!includedCountries.includes(country)) {
              return;
            }
            $.ajax( {
              url: countryCodesURL,
              type: "GET",
              async: true,
              dataType: "text",
              success: function ( rawCCData ) {
                var ccData = rawCCData.split(/\r?\n|\r/);
                var currRow;
                var name;
                var cc3;
                for (var i = 1; i < ccData.length; i++) {
                  currRow = ccData[i].split(", ");
                  name = currRow[0];
                  cc3 = currRow[2].slice(1, currRow[2].length - 1);
                  ccMap[name] = cc3;
                }

                $.ajax( {
                url: "combined-similarities.json",
                type: "GET",
                contentType: "application/json; charset=utf-8",
                async: true,
                dataType: "json",
                success: function ( inputData ) {
                    combined_similarities = inputData;
                    var fills = deriveColorScale(inputData);
                    var fillKeys = generateFillKeys(country, inputData);
                    getDomainData(country, inputData);
                    var basic_choropleth = new Datamap({
                      element: document.getElementById("basic_chloropleth"),
                      projection: 'mercator',
                      fills: fills,
                      data: fillKeys,
                      done: function(datamap) {
                        datamap.svg.selectAll('.datamaps-subunit').on('click', function(geography) {
                            country = geography.properties.name;
                            if (!includedCountries.includes(country)) {
                              return;
                            }
                            fillKeys = generateFillKeys(country, inputData);
                            datamap.updateChoropleth(fillKeys, {reset: true});
                            getDomainData(country, inputData);
                            document.getElementById("selected_country").innerHTML = "Selected Country: <div style = 'display: inline; color: blue;'>" + country + "</div>";
                            similarity_limits = drawLegend(country, fills, fillKeys);
                            min_similarity = similarity_limits[0];
                            max_similarity = similarity_limits[1];
                            drawLegendIntervals(min_similarity, max_similarity, num_intervals);
                        });
                      },
                      geographyConfig: {
                        borderColor: function(data) {
                          return '#b1b1b1';
                        },
                        popupTemplate: function(geography, data) {
                          return;
                        },
                        highlightOnHover: false,
                      },
                    });
                    similarity_limits = drawLegend(country, fills, fillKeys);
                    min_similarity = similarity_limits[0];
                    max_similarity = similarity_limits[1];
                    drawLegendIntervals(min_similarity, max_similarity, num_intervals);
              }});
            }});
          }

          var country = "United States of America";
          populateMap(country);
          document.getElementById("selected_country").innerHTML = "Selected Country: <div style = 'display: inline; color: blue;'>" + country + "</div>";
       </script>
    </body>
</html>
